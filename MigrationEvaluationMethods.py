#! /usr/bin/env python
# -*- coding: utf-8 -*-
# vim:fenc=utf-8
#
# Copyright © 2017 Caleb Robinson <calebrob6@gmail.com>
#
# Distributed under terms of the MIT license.
'''
Methods to evaluate the difference between ground truth migration flows and migration flows generated by models.
These are implementations of the methods described in [1] and [2].

[1] Lenormand, Maxime, Aleix Bassolas, and José J. Ramasco. "Systematic comparison of trip distribution laws and models." Journal of Transport Geography 51 (2016): 158-169.
[2] Lenormand, Maxime, et al. "A universal model of commuting networks." PloS one 7.10 (2012): e45985.
'''
import numpy as np

from sklearn.metrics import mean_absolute_error, mean_squared_error, median_absolute_error, r2_score

def evaluate_all(y_test, y_pred, distances):
    cpc_matrix  = cpc(y_test, y_pred)
    cpcd_matrix = cpc_d(y_test, y_pred, distances)
    
    mae_matrix = mean_absolute_error(y_test.flatten(), y_pred.flatten())
    r2_matrix = r2_score(y_test.flatten(), y_pred.flatten())
    
    y_test_incoming = y_test.sum(axis=0)
    y_pred_incoming = y_pred.sum(axis=0)
    
    mae_incoming = mean_absolute_error(y_test_incoming, y_pred_incoming)
    r2_incoming = r2_score(y_test_incoming, y_pred_incoming)

    return (cpc_matrix, cpcd_matrix, mae_matrix, r2_matrix, mae_incoming, r2_incoming)

#-----------------------------------------------------------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------------------
def cpc(O,G):
    '''Calcuates the common part of commuters value between the generated matrix, G, and the observed matrix, O as defined by Lenormand et al. in [2].

    returns: cpc value
    '''
    assert len(G.shape) == 2 and len(O.shape) == 2
    assert G.shape[0] == O.shape[0] and G.shape[1] == O.shape[1]
    
    numerator = 2.0 * np.sum(np.minimum(G,O))
    denominator = np.sum(O) + np.sum(G)
    
    return numerator/denominator

#-----------------------------------------------------------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------------------
def cpl(O,G):
    '''Calcuates the common part of links value between the generated matrix, G, and the observed matrix, O as defined by Lenormand et al. in [1].

    returns: cpl value
    '''
    assert len(G.shape) == 2 and len(O.shape) == 2
    assert G.shape[0] == O.shape[0] and G.shape[1] == O.shape[1]

    numerator = 2.0 * np.sum((O>0)&(G>0))
    denominator = np.sum(O>0) + np.sum(G>0)
    
    return numerator/denominator

#-----------------------------------------------------------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------------------
def cpc_d(O,G,distanceMatrix):
    '''Calcuates the common part of commuters according to distance value between the generated matrix, G, and
    the observed matrix, O as defined by Lenormand et al. in [1].

    returns: cpc_d value
    '''
    assert len(O.shape)==2 and len(G.shape)==2 and len(distanceMatrix.shape)==2
    assert O.shape[0] == G.shape[0] and O.shape[0] == distanceMatrix.shape[0]
    assert O.shape[1] == G.shape[1] and O.shape[1] == distanceMatrix.shape[1]

    binWidth = 2

    bins = np.arange(0, np.ceil(distanceMatrix.max())+1, binWidth)

    Omask = O > 0.0
    Gmask = G > 0.0

    oBins, oBinEdges = np.histogram(distanceMatrix[Omask].flatten(), bins=bins, weights=O[Omask].flatten())
    gBins, gBinEdges = np.histogram(distanceMatrix[Gmask].flatten(), bins=bins, weights=G[Gmask].flatten())

    numerator = np.sum(np.minimum(oBins,gBins))
    denominator = np.sum(oBins)

    return numerator/denominator

#-----------------------------------------------------------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------------------
def nrmse(O,G):
    '''Calcuates the normalized root mean squared error between the generated matrix, G, and the observed matrix, O as defined by Lenormand et al. in [1].

    Note: we have modified the definition to include the square root.

    returns: normalized root mean squared value
    '''
    assert len(G.shape) == 2 and len(O.shape) == 2
    assert G.shape[0] == O.shape[0] and G.shape[1] == O.shape[1]

    numerator = np.sum((O-G)**2)
    denominator = np.sum(O)
    
    return np.sqrt(numerator/denominator)

#-----------------------------------------------------------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------------------
def rmse(O,G):
    '''Calcuates the root mean squared error between the generated matrix, G, and the observed matrix, O.
     
    returns: root mean squared value
    '''
    assert len(G.shape) == 2 and len(O.shape) == 2
    assert G.shape[0] == O.shape[0] and G.shape[1] == O.shape[1]
 
    numerator = np.sum((O-G)**2)
    denominator = float(O.shape[0] * O.shape[1])
     
    return np.sqrt(numerator/denominator)

if __name__ == "__main__":
    pass